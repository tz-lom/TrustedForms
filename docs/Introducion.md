TrustedForms
================


Библиотека предназначена для генерации шаблонов и валидаторов для форм, используя декларативное описание ограничений накладывающихся на поля форм.
Так же библиотека способна генерировать JavaScript валидаторы для формы, чтобы производить проверки прямо в браузере.

Работа с библиотекой выглядит следующим образом:

1. Создание файла с формой и описанием полей
2. Компиляция файла в шаблон и валидатор
3. Использование валидатора как контейнера данных с формы
4. Использование шаблона для вывода формы.

Создание файла с формой и описанием полей
-----------------------------------------

Такой файл может быть простым HTML или же с PHP вставками. Описание формы заключается внутрь HTML комментария, который начинается с <!-- и заканчивается на -->.
Пример:

    <form>
        <input id="age" type="text" name="age" /><span id="errage"></span>
        <!--
            age {
                isNumeric: @#errage@<< Age must be number >> @#age@+error,
                inRange = (1,150) : @#errage@<< This cann't be your age >> @#age@+error
            }
        -->
        <input type="submit/>
    </form>
 
Ниже будет рассмотрен синтаксис самого языка описаний формы.

синтаксис языка описаний
------------------------

Все параметры и валидаторы накладываются на форму или поле на форме.
Форма или поле указывается по её имени (тэг name) , в файле может быть не более одной формы без имени, с полями без имени работать нельзя.

имя указывается либо в виде строки из букв английского алфавита, цифр и знака нижнего подчёркивания, при этом не начинающейся с цифры

    form
    form_1
    
либо в виде любой последовательности символов заключённой в кавычки

    "Моя форма"
    "123"
    "Кавычки можно \"экранировать"\ , в других случаях \ интерпретируется как знак"

чтобы указать имя формы, это имя должно быть заключено в угловые скобки (знаки больше и меньше)

    <form>
    <"My form">
    
такая запись выберет именно форму, и для неё действуют правила формы, а не полей

т.к. поле идентифицируется по имени, а в шаблоне может быть несколько полей с одинаковым именем в разных формах, можно дополнительно приписывать имя формы, при этом не важно в начало или конец имени поля

    <form>field
    "field"<"form">

после указания имёни идёт набор правил в фигурных скобках , разделённый запятыми

    имя { параметр1 , параметр2 , параметр3 }

у каждого правила есть свой идентификатор и опционально - набор значений
идентификатор - строка из букв английского алфавита, цифр и знака нижнего подчёркивания, не начинающаяся с цифры, вариант записи в скобках, как у имени, не поддерживается
если у параметра нужно указать опции то поддерживается 2 вида записи:

    идентификатор = значение,
    идентификатор = (значение1 , значение2 , итд),
    
в роли значения может выступать:
* имя
* любое значение в кавычках
* числа, в том числе отрицательные и дробные
* набор правил, в фигурных скобках
* специальная HTML запись - любой текст заключённый в двойные угловые скобки

    identifier = ( 12.6 , name , "long name" , { id = 4 , id2 = 5 } , << здесь можно легко писать <i style="font-weight:bold;">HTML тэги</i> с опциями >>)

после идентификатора (и не обязательной группы опций) может идти двоеточие и укзаываться один или несколько эффектов

    identifier : эффект эффект эффект
    identitier = 3 : эффект 
    identifier = (1 ,2 ) : эффект 

Эффекты описывают изменения в форме если данное правило вызвало ошибку.
Изменения могут быть:
* замена текста в элементе на свой
* добавление класса к элементу
* удаление класса у элемента

Эффекты записываются следующим образом
@ CSS селектор выбирающий элемент @<<специальная HTML запись>>
@ CSS selector @+className
@ CSS selector @-className

учтите - CSS селектор накладывается на доступный компилятору шаблон,а не на результирующую HTML страницу

имена классов могут быть идентификаторами или строками в двойных кавычках
модификации классов можно сцеплять, записывая последовательно

    @div.class@+class1-"спецкласс"

Правила для формы
---------------

**var**

Один параметр, задаёт имя переменной для формы (по умолчанию формы хранятся в переменных $form , $form1 , $form2 итд)
вместо имени можно записать "class Namespace\Classname" , тогда будет созданн класс Classname в пространстве имён Namespace , унаследованный от FormValidator

**enableJS**

Один параметр, принимает значения "true" или "false , позволяет отключить генерацию JS валидатора для всей формы (по умолчанию - включена)

**rpcServer**

Недокументированная возможность для указания URL который будет проверять форму на стороне сервера по мере заполнения её клиентом

**defaultErrorReport**

Без параметров. Эффекты описанные для этого правила будут использованны для всех правил всех полей этой формы, у которых не задан эффект

    <form> { defaultErrorReport: @.text@<<Error occured>> }
    field<form> { isInteger }

в таком случае если field не число будет показываться текст Error occured

**prefixRules**

один параметр,должен быть набором правил, задаёт набор правил накладываемых на каждое поле ДО правил описанных для него

    <form> { prefixRules: {isNumeric} }
    field<form> { inRange=(1,4) }

эквивалентно

    field<form> { isNumeric, inRange=(1,4) }

**postfixRules**

то же что и предидущее, только правила добавляются ПОСЛЕ правил поля

**comment**

один параметр, любой текст вставляемый перед описанием формы в PHP коде

    <form>{
        var = "class NS\Class",
        comment = "/**
     * Class to validate form
     */"
    }

Правила для поля
----------------

Помимо правил, для полей применяются валидаторы (то ради чего всё затевалось), о них чуть ниже

*disableJSvalidation*
Без параметров.Выключает генерацию JS валидатора для конкретного поля.

Валидаторы
----------

Валидатор это класс в пространстве имён ValueCheks , унаследованный от ValidationChainItem.
Валидатор способен как проверять значение, так и изменять его.
Так например валидатор isNumeric проверяет , не является ли значение числом, и возвращает ошибку если не является, а валидатор trim только выполняет trim из PHP , и не способен вернуть ошибку.

Список валидаторов
------------------

@ToDo: создать доку по валидаторам 
Вы можете открыть папку library/ValueChecks и ознакомится с валидаторами, к каждому идёт короткое описание в виде комментария к классу


Компиляция шаблона
-------------------

Для сборки шаблона существует класс CodeGenerator\Builder.
Параметром класса является имя библиотеки для обработки шаблонов.
Сейчас поддерживаеются только РНР шаблоны, существует 2 реализации:
* phpQueryTemplate
* NTMTemplate

phpQueryTemplate требует установленной библиотеки phpQuery http://code.google.com/p/phpquery/
NTMTemplate требует установленной бибиблиотеки NTM https://github.com/tz-lom/NTM

рекомендуется NTMTemplate

пример функции для сборки:

    function build($fname)
    {
        $pi = pathinfo($fname);

        $builder = new \TrustedForms\CodeGenerator\Builder('NTMTemplate');
        $builder->buildFile(file_get_contents($fname));

        file_put_contents($pi['dirname'].DIRECTORY_SEPARATOR.$pi['filename'].'.tpl', $builder->getResultTemplate());
        file_put_contents($pi['dirname'].DIRECTORY_SEPARATOR.$pi['filename'].'.php', "<?php\n".$builder->getResultValidator());
    }

так же есть скрипт library/CodeGenerator/buildform , но пока рекоммендуется использовать самописное решение т.к. приведённый скрипт весьма не удобен

Использование результатов
-------------------------
    require_once('Form.php');
    $form = new Namespace\Forms;
    if($form->checkArray($_REQUEST))
    {
        // форма прошла валидацию, можно смело использовать её данные
        echo 'age is: ', $form['age']->value(); 
    }
    require_once('Form.tpl'); // здесь будет вывод формы

